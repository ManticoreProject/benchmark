\documentclass[11pt]{article}
%
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\small,language=ML,breaklines=true,tabsize=2}

\begin{document}

This document focuses on the inner loop of the mandelbrot benchmark and its sequential optimization. The current benchmark on a two-processor machine has the following profiling breakdown:\footnote{Codegen literals are translated back into CFG variables.}
\begin{center}
\begin{tabular}{r|c}
\texttt{\_\_semwait\_signal} & 34.7\% \\
\texttt{then<F5D2>} & 24.9\% \\
\texttt{else<F5E3>} & 11.3\%\\
\texttt{manloop<D70D>} & 09.8\% \\
\end{tabular}
\end{center}

The first function is from an idle thread. The next one, the \texttt{then} block, is the set of raw multiplications. The final two, however, are performing references to allocated memory that might be removed and are covered in the two issue paragraphs that follow.

\paragraph {Original code}
The code below is the original inner sequential loop of the mandelbrot benchmark. I have renamed the inner function from \texttt{loop} to \texttt{manloop} because the compiler auto-generates quite a few intermediate functions named \texttt{loop}.

\begin{lstlisting}
fun elt (i, j) = let
  val delta = side / (Float.fromInt (N-1))
  val c_re = xBase + (delta * Float.fromInt j)
  val c_im = yBase - (delta * Float.fromInt i)
  fun manloop (cnt, z_re, z_im) = 
    if (cnt < maxCount)
    then let
      val z_re_sq = z_re * z_re
      val z_im_sq = z_im * z_im
    in
      if ((z_re_sq + z_im_sq) >= 4.0)
      then cnt
      else let
        val z_re_im = z_re * z_im
      in
        manloop(cnt+1, (z_re_sq - z_im_sq) + c_re, z_re_im + z_re_im + c_im)
      end
    end
    else cnt
  in
    manloop (0, c_re, c_im)
  end
\end{lstlisting}

\paragraph{Issue \#1 (CPS)}
Arity raising is only run once. The first time that analysis is done, the return continuation, \texttt{CFA1}, is of type \texttt{[int]}, so we think that is required. After the return continuation is flattened into just type \texttt{int}, though, we no longer need to keep the boxed integer around and could remove the allocation from the function altogether. Consider running arity raising to a fixpoint.

\begin{lstlisting}
fun manloop<CF9F>#2.2 (cnt<CFA3>#1:[int],_t<CFA7>#3:float,_t<CFAA>#3:float / retK<CFA1>#3.2:cont(int)) =
    let _t<CFA6>#4:int = #0(cnt<CFA3>#1)
    if I32Lt(_t<CFA6>#4,_lit<CDD7>#3) then
      let _t<CFA9>#2:float = F32Mul(_t<CFA7>#3,_t<CFA7>#3)
      let _t<CFAC>#2:float = F32Mul(_t<CFAA>#3,_t<CFAA>#3)
      let _t<CFAD>#1:float = F32Add(_t<CFA9>#2,_t<CFAC>#2)
      let _lit<CFAE>#1:float = 0.4e1:float
      if F32Gte(_t<CFAD>#1,_lit<CFAE>#1) then
        throw retK<CFA1>#3.2 _t<CFA6>#4
      else
        let _t<CFB1>#2:float = F32Mul(_t<CFA7>#3,_t<CFAA>#3)
        let _lit<CFB2>#1:int = 1:int
        let _t<CFB4>#1:int = I32Add(_t<CFA6>#4,_lit<CFB2>#1)
        let res<CFB5>#1:[int] = alloc (_t<CFB4>#1)
        let _t<CFB6>#1:float = F32Sub(_t<CFA9>#2,_t<CFAC>#2)
        let _t<CFB7>#1:float = F32Add(_t<CFB6>#1,_t<CF98>#2)
        let _t<CFB9>#1:float = F32Add(_t<CFB1>#2,_t<CFB1>#2)
        let _t<CFBA>#1:float = F32Add(_t<CFB9>#1,_t<CF9D>#2)
        apply manloop<CF9F>#2.2 (res<CFB5>#1,_t<CFB7>#1,_t<CFBA>#1 / retK<CFA1>#3.2)
    else
      throw retK<CFA1>#3.2 _t<CFA6>#4
let _lit<CFBD>#1:int = 0:int
let _wlit<CFBE>#1:[int] = alloc (_lit<CFBD>#1)
apply manloop<CF9F>#2.2 (_wlit<CFBE>#1,_t<CF98>#2,_t<CF9D>#2 / letJoinK<CFC1>#1)
\end{lstlisting}

\paragraph{Issue \#2 (CFG)}
If you look at the final else block, \texttt{F5E3}, you will see that the variables \texttt{c\_re} and \texttt{c\_im} from the enclosing \texttt{elt} function have been stored into the environment pointer and are being retrieved from memory into local variables on every single iteration. An alternative closure conversion strategy (even something closer to lambda lifting) might do something better when there are so few values to deal with.

\begin{lstlisting}
  kfun $manloop<D70D>#3 (
    ep<F5C3>#2,
    cnt<F5C4>#1,
    _t<F5C5>#1,
    _t<F5C6>#1,
    retK<F5C7>#2
  ) =
    let _t<F5CB>#3 = #0 cnt<F5C4>
    let _lit<F5CC>#1 = #0 ep<F5C3>
    if I32Lt(_t<F5CB>,_lit<F5CC>)
      then $then<F5D2>(ep<F5C3>,retK<F5C7>,_t<F5CB>,_t<F5C5>,_t<F5C6>)
      else $else<F5F2>(retK<F5C7>,_t<F5CB>)
  block $then<F5D2>#2 (
    ep<F5CD>#1,
    retK<F5D1>#2,
    _t<F5D0>#2,
    _t<F5CF>#3,
    _t<F5CE>#3
  ) =
    let _t<F5D3>#2 = F32Mul(_t<F5CF>,_t<F5CF>)
    let _t<F5D4>#2 = F32Mul(_t<F5CE>,_t<F5CE>)
    let _t<F5D5>#1 = F32Add(_t<F5D3>,_t<F5D4>)
    let _lit<F5D6>#1 = 0.4e1:float
    if F32Gte(_t<F5D5>,_lit<F5D6>)
      then $then<F5DA>(retK<F5D1>,_t<F5D0>)
      else $else<F5E3>(ep<F5CD>,retK<F5D1>,_t<F5D0>,_t<F5CF>,_t<F5D3>,_t<F5CE>,_t<F5D4>)
  block $else<F5F2>#2 (
    retK<F5F1>#1,
    _t<F5F0>#1
  ) =
    let retK<F5F3>#1 = $letJoinK<D70C>
    apply retK<F5F3>(retK<F5F1>,_t<F5F0>)
  block $then<F5DA>#2 (
    retK<F5D9>#1,
    _t<F5D8>#1
  ) =
    let retK<F5DB>#1 = $letJoinK<D70C>
    apply retK<F5DB>(retK<F5D9>,_t<F5D8>)
  block $else<F5E3>#2 (
    ep<F5DC>#3,
    retK<F5E2>#1,
    _t<F5E1>#1,
    _t<F5E0>#1,
    _t<F5DF>#1,
    _t<F5DE>#1,
    _t<F5DD>#1
  ) =
    let _t<F5E4>#2 = F32Mul(_t<F5E0>,_t<F5DE>)
    let _lit<F5E5>#1 = 1:int
    let _t<F5E6>#1 = I32Add(_t<F5E1>,_lit<F5E5>)
    let res<F5E7>#1 = alloc (_t<F5E6>)
    let _t<F5E8>#1 = F32Sub(_t<F5DF>,_t<F5DD>)
    let _t<F5EA>#1 = #1 ep<F5DC>
    let _t<F5E9>#1 = F32Add(_t<F5E8>,_t<F5EA>)
    let _t<F5EB>#1 = F32Add(_t<F5E4>,_t<F5E4>)
    let _t<F5ED>#1 = #2 ep<F5DC>
    let _t<F5EC>#1 = F32Add(_t<F5EB>,_t<F5ED>)
    let manloop<F5EE>#1 = $manloop<D70D>
    apply manloop<F5EE>(ep<F5DC>,res<F5E7>,_t<F5E9>,_t<F5EC>,retK<F5E2>)
\end{lstlisting}

\end{document}